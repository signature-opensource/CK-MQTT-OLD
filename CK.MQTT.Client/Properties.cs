using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Resources;

namespace CK.MQTT
{
    public static class Properties
    {
        public const string ByteExtensions_InvalidBitPosition = "Bit position must be between 0 and 7";
        public const string ByteExtensions_InvalidByteIndex = "Byte index must be from 1 to 8, starting from msb";
        public const string Client_AlreadyConnected = "The protocol connection cannot be performed because an active connection for client {0} already exists";
        public const string Client_AlreadyDisconnected = "The protocol disconnection cannot be performed because the client is already disconnected";
        public const string Client_AnonymousClientWithoutCleanSession = "Anonymous clients must set the \"cleanSession\" parameter to true in order to perform the protocol connection";
        public const string Client_CleanedOldSession = "Client {0} - Cleaned old session";
        public const string Client_Closing = "Client {0} - Closing. Reason: {1}";
        public const string Client_ConnectionDisconnected = "The client {0} has been disconnected while trying to perform the connection";
        public const string Client_ConnectionError = "An error occurred while trying to connect the client {0}";
        public const string Client_ConnectionTimeout = "A timeout occured while waiting for the client {0} connection confirmation";
        public const string Client_ConnectNotAccepted = "The connect packet of client {0} has not been accepted by the server. Status: {1}. The connection will be closed";
        public const string Client_CreatedSession = "Client {0} - Created new client session";
        public const string Client_DeletedSessionOnDisconnect = "Client {0} - Removed client session";
        public const string Client_InitializeError = "An error occurred while initializing a client";
        public const string Client_NewApplicationMessageReceived = "Client {0} - An application message for topic {1} was received";
        public const string Client_PacketsObservableCompleted = "Client - Packet observable sequence has been completed, hence closing the channel";
        public const string Client_SubscribeError = "An error occurred while trying to subscribe the client {0} to topic {1}";
        public const string Client_SubscribeTimeout = "A timeout occured while waiting for the subscribe confirmation of client {0} for topic {1}";
        public const string Client_SubscriptionDisconnected = "The client {0} has been disconnected while trying to perform the subscription to topic {1}";
        public const string Client_SubscriptionRejected = "The server has rejected the subscription of client {0} to topic {1}";
        public const string Client_UnexpectedChannelDisconnection = "The underlying connection has been disconnected unexpectedly";
        public const string Client_UnsubscribeDisconnected = "The client {0} has been disconnected while trying to perform the unsubscribe to topics: {1}";
        public const string Client_UnsubscribeError = "An error occurred while trying to unsubscribe the client {0} of topics: {1}";
        public const string Client_UnsubscribeTimeout = "A timeout occured while waiting for the unsubscribe confirmation of client {0} for topics: {1}";
        public const string ClientPacketListener_DispatchingMessage = "Client {0} - Dispatching {1} message to flow {2}";
        public const string ClientPacketListener_DispatchingPublish = "Client {0} - Dispatching Publish message to flow {1} and topic {2}";
        public const string ClientPacketListener_Error = "Client - An error occurred while listening and dispatching packets";
        public const string ClientPacketListener_FirstPacketReceived = "Client {0} - First packet from Server has been received. Type: {1}";
        public const string ClientPacketListener_FirstReceivedPacketMustBeConnectAck = "The first packet received from the Server must be a ConnectAck packet. The connection will be closed.";
        public const string ClientPacketListener_PacketChannelCompleted = "Client {0} - Packet Channel observable sequence has been completed";
        public const string ClientPacketListener_SendingKeepAlive = "Client {0} - No packet has been sent in {1} seconds. Sending Ping to Server to maintain Keep Alive";
        public const string ConnectAckFormatter_InvalidAckFlags = "Bits 7-1 from Acknowledge flags are reserved and must be set to 0";
        public const string ConnectAckFormatter_InvalidSessionPresentForErrorReturnCode = "Session Present flag must be set to 0 for non-zero return codes";
        public const string ConnectFormatter_ClientIdEmptyRequiresCleanSession = "Client Ids with zero bytes length requires the Clean Session value to be 1 (true)";
        public const string ConnectFormatter_ClientIdMaxLengthExceeded = "Client Id cannot exceed 23 bytes";
        public const string ConnectFormatter_InvalidClientIdFormat = "{0} is an invalid ClientId. It must contain only numbers and letters";
        public const string ConnectFormatter_InvalidPasswordFlag = "Password Flag must be set to 0 if the User Name Flag is set to 0";
        public const string ConnectFormatter_InvalidProtocolName = "{0} is not a valid protocol name";
        public const string ConnectFormatter_InvalidReservedFlag = "Reserved Flag must be always set to 0";
        public const string ConnectFormatter_InvalidWillRetainFlag = "Will Retain Flag must be set to 0 if the Will Flag is set to 0";
        public const string ConnectFormatter_PasswordNotAllowed = "Password value must be null or empty if User value is null or empty";
        public const string ConnectFormatter_UnsupportedLevel = "Protocol Level {0} is not supported by the server";
        public const string Formatter_InvalidHeaderFlag = "Header Flag {0} is invalid for {1} packet. Expected value: {2}";
        public const string Formatter_InvalidPacket = "The packet sent cannot be handled by {0}";
        public const string Formatter_InvalidQualityOfService = "Qos value must be from 0x00 to 0x02";
        public const string Mqtt_Disposing = "Disposing {0}...";
        public const string MqttChannel_ClientNotConnected = "The underlying communication stream is not connected";
        public const string MqttChannel_DisposeError = "An error occurred while closing underlying communication channel. Error code: {0}";
        public const string MqttChannel_NetworkStreamCompleted = "The underlying communication stream has completed sending bytes. The observable sequence will be completed and the channel will be disposed";
        public const string MqttChannel_ReceivedPacket = "Received packet of {0} bytes";
        public const string MqttChannel_SendingPacket = "Sending packet of {0} bytes";
        public const string MqttChannel_StreamDisconnected = "The underlying communication stream is not available. The socket could have been disconnected";
        public const string PacketChannelFactory_InnerChannelFactoryNotFound = "An inner channel factory is required to create a new packet channel";
        public const string PacketManager_PacketUnknown = "The received packet cannot be handled by any of the registered formatters";
        public const string ProtocolEncoding_IntegerMaxValueExceeded = "Integer values are expected to be of two bytes length. The max value supported is 65536";
        public const string ProtocolEncoding_MalformedRemainingLength = "Malformed Remaining Length";
        public const string ProtocolEncoding_StringMaxLengthExceeded = "String value cannot exceed 65536 bytes of length";
        public const string ProtocolFlowProvider_InvalidPacketType = "The packet type {0} cannot be handled by this flow provider";
        public const string ProtocolFlowProvider_UnknownPacketType = "An error occured while trying to get a Flow Type based on Packet Type {0}";
        public const string PublishFlow_RetryingQoSFlow = "The ack for message {0} has not been received. Re sending message for client {1}";
        public const string PublishFormatter_InvalidDuplicatedWithQoSZero = "Duplicated flag must be set to 0 if the QoS is 0";
        public const string PublishFormatter_InvalidPacketId = "Packet Id is not allowed for packets with QoS 0";
        public const string PublishFormatter_InvalidTopicName = "Topic name {0} is invalid. It cannot be null or empty and It must not contain wildcard characters";
        public const string PublishFormatter_PacketIdRequired = "Packet Id value cannot be null or empty for packets with QoS 1 or 2";
        public const string PublishReceiverFlow_PacketIdNotAllowed = "Packet Id value is not allowed for QoS 0";
        public const string PublishReceiverFlow_PacketIdRequired = "Packet Id value is required for QoS major than 0";
        public const string SessionRepository_ClientSessionNotFound = "No session has been found for client {0}";
        public const string SubscribeAckFormatter_InvalidReturnCodes = "Return codes can only be valid QoS values or a failure code (0x80)";
        public const string SubscribeAckFormatter_MissingReturnCodes = "A subscribe acknowledge packet must contain at least one return code";
        public const string SubscribeFormatter_InvalidTopicFilter = "Topic filter {0} is invalid. See protocol specification for more details on Topic Filter rules: http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718106";
        public const string SubscribeFormatter_MissingTopicFilterQosPair = "A subscribe packet must contain at least one Topic Filter / QoS pair";
        public const string TcpChannelFactory_TcpClient_Failed = "An error occurred while connecting via TCP to the endpoint address {0} and port {1}, to establish an MQTT connection";
        public const string TcpChannelProvider_TcpListener_Failed = "An error occurred while starting to listen incoming TCP connections";
        public const string TopicEvaluator_InvalidTopicFilter = "The topic filter {0} is invalid according to the protocol rules and configuration";
        public const string TopicEvaluator_InvalidTopicName = "The topic name {0} is invalid according to the protocol rules";
        public const string UnsubscribeFormatter_MissingTopics = "An unsubscribe packet must contain at least one topic to unsubscribe";
        public const string WebSocketChannelFactory_WebSocketClient_Failed = "An error occurred while connecting via Web Sockets to the endpoint address {0}, to establish an MQTT connection";
    }
}
