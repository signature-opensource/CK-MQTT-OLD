using System.Diagnostics;
using System.Linq;
using System.Reflection;
using System.Resources;

namespace CK.MQTT
{
    public static class Properties
    {
        public static string ConnectFormatter_InvalidClientIdFormat => "{0} is an invalid ClientId. It must contain only numbers and letters";
        public static string ConnectFormatter_InvalidProtocolName => "{0} is not a valid protocol name";
        public static string SubscribeAckFormatter_MissingReturnCodes => "A subscribe acknowledge packet must contain at least one return code";
        public static string SubscribeFormatter_MissingTopicFilterQosPair => "A subscribe packet must contain at least one Topic Filter / QoS pair";
        public static string Client_ConnectionTimeout => "A timeout occured while waiting for the client {0} connection confirmation";
        public static string Client_SubscribeTimeout => "A timeout occured while waiting for the subscribe confirmation of client {0} for topic {1}";
        public static string Client_UnsubscribeTimeout => "A timeout occured while waiting for the unsubscribe confirmation of client {0} for topics: {1}";
        public static string ProtocolFlowProvider_UnknownPacketType => "An error occured while trying to get a Flow Type based on Packet Type {0}";
        public static string MqttChannel_DisposeError => "An error occurred while closing underlying communication channel. Error code: {0}";
        public static string TcpChannelFactory_TcpClient_Failed => "An error occurred while connecting via TCP to the endpoint address {0} and port {1}, to establish an MQTT connection";
        public static string Client_InitializeError => "An error occurred while initializing a client";
        public static string TcpChannelProvider_TcpListener_Failed => "An error occurred while starting to listen incoming TCP connections";
        public static string Client_ConnectionError => "An error occurred while trying to connect the client {0}";
        public static string Client_SubscribeError => "An error occurred while trying to subscribe the client {0} to topic {1}";
        public static string Client_UnsubscribeError => "An error occurred while trying to unsubscribe the client {0} of topics: {1}";
        public static string PacketChannelFactory_InnerChannelFactoryNotFound => "An inner channel factory is required to create a new packet channel";
        public static string UnsubscribeFormatter_MissingTopics => "An unsubscribe packet must contain at least one topic to unsubscribe";
        public static string Client_AnonymousClientWithoutCleanSession => "Anonymous clients must set the \"cleanSession\" parameter to true in order to perform the protocol connection";
        public static string ByteExtensions_InvalidBitPosition => "Bit position must be between 0 and 7";
        public static string ConnectAckFormatter_InvalidAckFlags => "Bits 7-1 from Acknowledge flags are reserved and must be set to 0";
        public static string ByteExtensions_InvalidByteIndex => "Byte index must be from 1 to 8, starting from msb";
        public static string ClientPacketListener_Error => "Client - An error occurred while listening and dispatching packets";
        public static string Client_PacketsObservableCompleted => "Client - Packet observable sequence has been completed, hence closing the channel";
        public static string Client_NewApplicationMessageReceived => "Client {0} - An application message for topic {1} was received";
        public static string Client_CleanedOldSession => "Client {0} - Cleaned old session";
        public static string Client_Closing => "Client {0} - Closing. Reason: {1}";
        public static string Client_CreatedSession => "Client {0} - Created new client session";
        public static string ClientPacketListener_DispatchingMessage => "Client {0} - Dispatching {1} message to flow {2}";
        public static string ClientPacketListener_DispatchingPublish => "Client {0} - Dispatching Publish message to flow {1} and topic {2}";
        public static string ClientPacketListener_FirstPacketReceived => "Client {0} - First packet from Server has been received. Type: {1}";
        public static string ClientPacketListener_SendingKeepAlive => "Client {0} - No packet has been sent in {1} seconds. Sending Ping to Server to maintain Keep Alive";
        public static string ClientPacketListener_PacketChannelCompleted => "Client {0} - Packet Channel observable sequence has been completed";
        public static string Client_DeletedSessionOnDisconnect => "Client {0} - Removed client session";
        public static string ConnectFormatter_ClientIdMaxLengthExceeded => "Client Id cannot exceed 23 bytes";
        public static string ConnectFormatter_ClientIdEmptyRequiresCleanSession => "Client Ids with zero bytes length requires the Clean Session value to be 1 (true)";
        public static string Mqtt_Disposing => "Disposing {0}...";
        public static string PublishFormatter_InvalidDuplicatedWithQoSZero => "Duplicated flag must be set to 0 if the QoS is 0";
        public static string Formatter_InvalidHeaderFlag => "Header Flag {0} is invalid for {1} packet. Expected value: {2}";
        public static string ProtocolEncoding_IntegerMaxValueExceeded => "Integer values are expected to be of two bytes length. The max value supported is 65536";
        public static string ProtocolEncoding_MalformedRemainingLength => "Malformed Remaining Length";
        public static string SessionRepository_ClientSessionNotFound => "No session has been found for client {0}";
        public static string PublishFormatter_InvalidPacketId => "Packet Id is not allowed for packets with QoS 0";
        public static string PublishFormatter_PacketIdRequired => "Packet Id value cannot be null or empty for packets with QoS 1 or 2";
        public static string PublishReceiverFlow_PacketIdNotAllowed => "Packet Id value is not allowed for QoS 0";
        public static string PublishReceiverFlow_PacketIdRequired => "Packet Id value is required for QoS major than 0";
        public static string ConnectFormatter_InvalidPasswordFlag => "Password Flag must be set to 0 if the User Name Flag is set to 0";
        public static string ConnectFormatter_PasswordNotAllowed => "Password value must be null or empty if User value is null or empty";
        public static string ConnectFormatter_UnsupportedLevel => "Protocol Level {0} is not supported by the server";
        public static string Formatter_InvalidQualityOfService => "Qos value must be from 0x00 to 0x02";
        public static string MqttChannel_ReceivedPacket => "Received packet of {0} bytes";
        public static string ConnectFormatter_InvalidReservedFlag => "Reserved Flag must be always set to 0";
        public static string SubscribeAckFormatter_InvalidReturnCodes => "Return codes can only be valid QoS values or a failure code (0x80)";
        public static string MqttChannel_SendingPacket => "Sending packet of {0} bytes";
        public static string ConnectAckFormatter_InvalidSessionPresentForErrorReturnCode => "Session Present flag must be set to 0 for non-zero return codes";
        public static string ProtocolEncoding_StringMaxLengthExceeded => "String value cannot exceed 65536 bytes of length";
        public static string PublishFlow_RetryingQoSFlow => "The ack for message {0} has not been received. Re sending message for client {1}";
        public static string Client_ConnectionDisconnected => "The client {0} has been disconnected while trying to perform the connection";
        public static string Client_SubscriptionDisconnected => "The client {0} has been disconnected while trying to perform the subscription to topic {1}";
        public static string Client_UnsubscribeDisconnected => "The client {0} has been disconnected while trying to perform the unsubscribe to topics: {1}";
        public static string Client_ConnectNotAccepted => "The connect packet of client {0} has not been accepted by the server. Status: {1}. The connection will be closed";
        public static string ClientPacketListener_FirstReceivedPacketMustBeConnectAck => "The first packet received from the Server must be a ConnectAck packet. The connection will be closed.";
        public static string Formatter_InvalidPacket => "The packet sent cannot be handled by {0}";
        public static string ProtocolFlowProvider_InvalidPacketType => "The packet type {0} cannot be handled by this flow provider";
        public static string Client_AlreadyConnected => "The protocol connection cannot be performed because an active connection for client {0} already exists";
        public static string Client_AlreadyDisconnected => "The protocol disconnection cannot be performed because the client is already disconnected";
        public static string PacketManager_PacketUnknown => "The received packet cannot be handled by any of the registered formatters";
        public static string Client_SubscriptionRejected => "The server has rejected the subscription of client {0} to topic {1}";
        public static string TopicEvaluator_InvalidTopicFilter => "The topic filter {0} is invalid according to the protocol rules and configuration";
        public static string TopicEvaluator_InvalidTopicName => "The topic name {0} is invalid according to the protocol rules";
        public static string MqttChannel_NetworkStreamCompleted => "The underlying communication stream has completed sending bytes. The observable sequence will be completed and the channel will be disposed";
        public static string MqttChannel_StreamDisconnected => "The underlying communication stream is not available. The socket could have been disconnected";
        public static string MqttChannel_ClientNotConnected => "The underlying communication stream is not connected";
        public static string Client_UnexpectedChannelDisconnection => "The underlying connection has been disconnected unexpectedly";
        public static string SubscribeFormatter_InvalidTopicFilter => "Topic filter {0} is invalid. See protocol specification for more details on Topic Filter rules: http://docs.oasis-open.org/mqtt/mqtt/v3.1.1/os/mqtt-v3.1.1-os.html#_Toc398718106";
        public static string PublishFormatter_InvalidTopicName => "Topic name {0} is invalid. It cannot be null or empty and It must not contain wildcard characters";
        public static string ConnectFormatter_InvalidWillRetainFlag => "Will Retain Flag must be set to 0 if the Will Flag is set to 0";
    }
}
